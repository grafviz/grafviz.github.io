<!DOCTYPE html>
<meta charset = "utf-8">
<html>
<head>
  <title>Clustered Network</title>


  <script src = "https://d3js.org/d3.v3.min.js"></script>
  <!--<script src = "d3.js"></script>-->


  <style type = "text/css">
  svg {
    border: 1px solid #ccc;
  }
  body {
    font: 10px sans-serif;
  }

 
  

  .node text {
    fill:black;
    font-size:18px;
    text-anchor:middle; 
  }


  polygon.focus{
    stroke:black;
    opacity:1; 
  }

  polygon.background{
    stroke:grey;
    opacity:.2; 
  }
  

  path.hull {
    fill: lightsteelblue;
    fill-opacity: 0.3;
  }




  </style>
</head>
<body> 
  <script type = "text/javascript">

  //TO DO:   changer polices, empêcher sortir, passer à D3 v4?, prendre en compte plusieurs parents, ouvrir partiellement un noeud, déterminer la transparence d'un noeud ouvert en fonction de ses liens transversaux (cf agnes buzyn), utiliser hierarchy package

var width = 3*960,     // svg width
    height = 3*600,     // svg height 
    marge = 100,    //keep points away from the edges
    bound = true,     //keep points in the box
    dr = 34,      // default point radius
    off = 10,    // cluster hull offset 
    nodes = [],
    links=[],
    nodesMap =  {} ,  //"name" -> number
    focus = "France",
    compteur=0,
    net, force, hullg, hull, linkg, link, linkp,  nodeg, nodeh, nodehg, node, infot, InfoRect, infog

    curve = d3.svg.line()
    .interpolate("cardinal-closed")
    .tension(.85),

    fill = d3.scale.category20(); 
// --------------------------------------------------------

var body = d3.select("body");


//zoom ability
var zoom = d3.behavior.zoom()
.scaleExtent( [ .1, 10 ] )
.on("zoom", zoomed);

//drag ability
var drag = d3.behavior.drag()
.origin(d => d)
.on("dragstart", dragstarted)
.on("drag", dragged)
.on("dragend", dragended);

var canv = body.append("svg").attr("id","canv")
.attr("width", width)
.attr("height", height).call(zoom);

focusvis = canv.append("svg").attr("transform","translate(1,1)").attr("id","focusvis");

vis = focusvis.append("svg").attr("id","vis");

//info text when cursor is over convex hull
crsrText = vis.append("text").attr("id","crsrtxt");


d3.json("conflicts-file-v2.json", function(json) {
  data = json;  
  console.log(data)

  //extract nodes
  for (var i = 0; i<data.length; ++i) {
    nodei = data[ i ] ;
    if (nodei.id!=""){
      nodesMap [ nodei.id ] = nodes.length;
      nodei.children = [  ] ;
      nodei.expanded=false;
      nodei.x = width*Math.random()/3;
      nodei.y = height*Math.random()/3; 
      nodei.px = nodei.x
      nodei.py = nodei.y; 
      nodei.prevShow=false;
      nodei.linked=[];
      //on demarre avec les enfants de world
      nodei.visibleParent=1;
      if (nodei.parent == "world") {nodei.show = true;}
      else {nodei.show = false;} 
      nodes.push(nodei)

    //on ajoute les liens de parenté
      links.push({source:nodei.id,  target:nodei.parent, params: {type:"belongsTo"}}); 
    }
  } 
  //world est tjs expanded
  nodes[0].expanded=true;

  console.log(nodesMap)

  //extract links
  for (var i=1; i<data.length; i++){

      linki=data[i].link||{target:""};

      console.log(links, linki)
    if (linki.target!=""){
      links.push(linki)

      //on verifie que parent existe, ou target Parent
      if (nodesMap[linki.target]){
        console.log(linki.targetName," existe");}
      else if (linki.targetParentId) {
           console.log("création de ",linki.targetName);
           nodesMap[linki.target]=nodes.length; 
           tgtName=linki.targetName.split(" ");
           nodes.push({
            id:linki.target,
            firstName:tgtName.shift(),
            lastName:tgtName.join(),
            parent:linki.targetParentId,
            children : [  ],
            expanded:false, 
            show:false,
            linked:[],
            params:{},
            prevShow:false});
            links.push({source:linki.target,  target:linki.targetParentId, params: {type:"belongsTo"}});

        }
        else {console.log("parent inconnu",linki.parent);
              a=bb;
        }
        nodeById(linki.source).linked.push(linki.target);
        nodeById(linki.target).linked.push(linki.source);
      }
  } 
 

  //build children lists and links
  for (var i = 1; i<nodes.length; ++i) { 
    nodei = nodes[ i ] ; 
    parent = nodeById( nodei.parent )
    parent.children.push(nodei);
 
  
  } 

  //force needs the actual source and target
  for (var i = 0; i<links.length; ++i) { 
    linki = links [ i ] ;
    //linki.source = nodes [ nodesMap [ linki.sourceName ]  ] ;
    //linki.target = nodes [ nodesMap [ linki.targetId ] ] ;
     
    if (!linki.target){a=bb}
  }

  console.log("data",nodes,links)
 



  //on met les elements svg dans l'ordre sur la page html
  hullg = vis.append("g").attr("id","hullg");//env. convexes
  nodehg=vis.append("g").attr("id","nodehg");//halos des noeuds
  linkg = vis.append("g").attr("id","linkg");//liens
  nodeg = vis.append("g").attr("id","nodeg");//nodeuds 
  infoG=focusvis.append("g").attr("id","infog")
  .on("click",d=> infog.setAttribute("display","none"));


  infog=document.getElementById("infog")

  infoG.append("rect")
  .attr("id","infoRect")
  .attr("x",20)
  .attr("y",20)
  .attr("rx","5px")
  .attr("width",1)
  .attr("height",1)
  .attr("fill","lightblue")
  .style("opacity",.9) 

  infot=infoG.append("text") 
  .attr("id","infoTxt")
  .attr("stroke-width",".5px")
  .attr("x",50)
  .attr("y",60) 
 

  //on lance la simulation
  init();

  //effet apparition progressive
  vis.attr("opacity", 1e-6)
  .transition()
  .duration(2000)
  .attr("opacity", 1);
});


function init() { 
  compteur=compteur+1;
  if (force) force.stop();//useful?
  console.log("------init - focus",focus)
  console.log("data",nodes,links) 
  
  net = network(nodes,links,nodesMap);
  console.log("net",net) 

  force = d3.layout.force()
  .nodes(net.nodes)
  .links(net.links)
  .size( [ width/2, height/2 ] )
  //.linkDistance(function(l, i) { return 600; })
  .linkStrength(function(l, i) { return ((l.source.id==focus) || (l.target.id==focus))? 0.005 : 0.001; })
  .gravity(0.007)    
  .charge(function(n,i) {  return (n.id == focus?-200:-100);})
  .chargeDistance(600)
  .friction(0.9) 
  .start();



  //A noter: force transforme links: il remplace link.source.id par l'objet source, etc... 
  console.log("data",nodes,links)

  //convex hull cursor text------------
  vis.on("mouseover",function(){
    x = d3.mouse(this) [ 0 ] ;
    y = d3.mouse(this) [ 1 ] ;
    crsrText.attr("x",x)
    .attr("y",y)
    .attr("display","");
  })

  vis.on("mousemove",function(){
    x = d3.mouse(this) [ 0 ] ;
    y = d3.mouse(this) [ 1 ] ;
    crsrText.attr("x",x)
    .attr("y",y)
    .attr("display","");
  })

  vis.on("mouseout",function(){  
    crsrText.attr("display","none");
  })

  //hulls display----------------------- 
  hullg.selectAll("path.hull").remove();
  hull = hullg.selectAll("path.hull")
  .data(convexHulls(net.nodes, nodesMap, off))
  .enter().append("path")
  .attr("class", "hull")
  .attr("d", drawCluster)
  .style("fill", d => fill(nodesMap [ d.parent ] ) )
  .on("mouseover",d =>   crsrText.text(d.parent))
  .on("click", function(d) {
    if (d.parent!= "world") {
      console.log("hull click", d, arguments, this); 
      focus = d.parent;  
      console.log("collaps")
      collapseNode(nodeById(d.parent));
      init(); 
    } 
  });  



  //nodes display------------------- 
  if (node) {node.remove();};//on peut aussi n'enlever que certains noeuds
  if (nodeh) {nodeh.remove();};
  node = nodeg.selectAll(".node").data(net.nodes,d=>d.id);//, nodeid);
  nodeh=nodehg.selectAll(".nodeh").data(net.nodes,d=>d.id);

  //node.exit().remove();
  node.enter()
  .append("g") 
  .attr("class","node")
  .style("opacity", d=> d.expanded? 0.3:1)
  .attr("transform",d => "translate("+d.x+","+d.y+")")

  nodeh.enter()
  .append("circle") 
  .attr("class","nodeh")
  .filter( d => (d.children.length>0 && !d.expanded))
  .attr("r",d=>dr+ 10+size(d)*0.5)
  .attr("cx",d=>d.x) 
  .attr("cy",d=> d.y) 
  .style("fill",d=>fill(nodesMap [ d.parent ] ))
  .style("opacity",.5)
  .on("click", function(d) {  
      console.log("node click", d, arguments, this);
      focus=d.id;
        expandNode(d); 
        init();
  })
  .on("mouseover", d => infoDisp(d,"node"))
  //.on("mouseout",d =>infog.setAttribute("display","none"));

  node.append("circle") 
  .attr("stroke-width","5px")
  .attr("stroke",'lightgrey')
  .attr("r", d => dr) //sqrt(size(d)) would be more relevant
  .attr("cx",0) 
  .attr("cy",0) 
  .style("fill", d => fill(nodesMap [ d.parent ] ))
  .on("click", function(d) { 
        if (focus==d.id){
          if (d.expanded) {
            collapseNode(d);}
          d.show=nodeById(d.parent).expanded;
          console.log(d.show) 
        }
        //on range l'ancien focus, sauf si on clique sur un noeud déballé
        focusLinked=nodeById(focus).linked;
        for (k in focusLinked){
          nodek=nodeById(focusLinked[k]);
          nodek.show=nodeById(nodek.parent).expanded? true: d.id==nodek.id? true: false;
          nodek.prevShow=true;
          console.log(nodek) 
        } 
        //on installe le nouveau focus
        focus = d.id;
        focusLinked=nodeById(d.id).linked;
        for (k in focusLinked){
          nodek=nodeById(focusLinked[k]);
          nodek.prevShow=nodek.show;
          nodek.show=true;
        } 
    init();})
  .on("mouseover", d=> infoDisp(d,"node"))
  //.on("mouseout",d =>  infog.setAttribute("display","none"));

  node.append("text") 
  .attr("x",0)
  .attr("y",d => d.lastName? "-1.2em" : 0)
  .style("font-size","18px")
  .text( d => d.firstName)

  node.append("text") 
  .attr("x",0)
  .attr("y", 0)
  .text( d => d.lastName||"") 
  
  node.append("text")
  .style("font-size","10px")
  .attr("dy","2em")
  .text(d => name(d.parent)) 

  node.sort(nodeSort)


  //links display------------
  if (link) {link.remove();};//on pourrait aussi n'enlever que certains liens
  link = linkg.selectAll("link").data(net.links);
 

  link.enter().append("g")
  .attr("class","link")
  .attr("transform", d => "translate(" + d.source.x + "," + d.source.y + ")")
  .on("mouseover", d =>  d.params.type=="belongsTo"? null : infoDisp(d,"link"))
  .on("click", d=>infog.setAttribute("display","none"));
  //.on("mouseout", d  => infog.setAttribute("display","none"));

  linkp = link.append("polygon")
  .attr("class",d => ((d.source.id == focus)||(d.target.id == focus))? "focus":"background")
  .attr("points",function(d) {
    var dx = d.target.x-d.source.x;
    var dy = d.target.y-d.source.y;
    return "0 0 "+dx+" "+dy}) 
  .style("stroke-width", d => d.params.type=="belongsTo"?   1 : 10)  

  link.sort(linkSort)



//Force updates------------------------------

node.call(force.drag);

force.on("tick", function() { 
  if (!hull.empty()) {
    hull.data(convexHulls(net.nodes, nodesMap, off))
    .attr("d", drawCluster);
  }


  node.attr("transform", d => "translate(" + boxBoundx(d.x) + "," + boxBoundy(d.y) + ")" ); 

  nodeh.attr("cx",d=>d.x).attr("cy",d=>d.y)


  link
  .attr("transform", d => "translate(" + boxBoundx(d.source.x )+ "," + boxBoundy(d.source.y) + ")" ) 

  linkp.attr("points",function(d) {
    var dx = boxBoundx(d.target.x)-boxBoundx(d.source.x);
    var dy = boxBoundy(d.target.y)-boxBoundy(d.source.y);
    return "0 0 "+dx+" "+dy}) 
 



});

}

function toggleInfo(i,classe,disp){  

  crsrText.text("") ; 



  var element = document.getElementById(classe+"frameg"+i); 

  element.setAttribute("display", disp)

  if (disp!="none") {
    var rect = document.getElementById(classe+"frame"+i);
    //dims du texte dans le "g" parent 
    textHeight=rect.parentNode.childNodes[1].getBBox().height;
    textWidth=rect.parentNode.childNodes[1].getBBox().width;
    
    rect.setAttribute("height",textHeight+40)
    rect.setAttribute("width",textWidth+40)

  } 
    //console.log(element.selectAll("rect").setAttribute("height",20))
  }


  function boxBoundx(x){ 
   if (bound) {
    return Math.min(width-marge,Math.max(marge,x));}
    else {return x}
  }

function boxBoundy(y){ 
  if (bound) {
    return Math.min(height-marge,Math.max(marge,y));}
    else {return y}
  }

/*function linkid(l) {
  var u = nodeid(l.source),
  v = nodeid(l.target);
  return u<v ? u+"|"+v : v+"|"+u;
}*/



function network(nodes,links,nodesMap){ //il faudrait prevoir qqch pour que les noeuds qui viennent d'éclore soient répartis près du centre, sinon ils sont mis par défaut en haut à gauche et ça explose

console.log("network data",nodes,links);
var displayedNodes = [  ] , link, node,
displayedNodesMap = [  ] ,
      //linksSynth = [  ] ,   
      i = 0; 
  //build nodes maps (except world)
  for (var k = 1; k<nodes.length; ++k){
    node = nodes [ k ] ;

    if (node.show) {
      displayedNodes.push(node);
      displayedNodesMap [ k ] = i;
      i++;
    }  
  } 

  console.log(nodes)
  nodes[0].visibleParent=1;

  for (var k = 1; k<nodes.length; ++k){ 
    var looking = true;
    var current = k; 
    nodek=nodes[k];  
    while (looking ){ 
      crtNode = nodes [ current ] ; 
      parentIndex = nodesMap [ crtNode.parent ] ;  
      if (crtNode.show == false ) {//si le noeud est caché
      //on l'ajoute au noeud de son parent direct 
      current = parentIndex; } 
      else {
        if (nodek.show!=nodek.prevShow) {
        //just popped 
        console.log("pop",nodek)
        nodek.prevShow=true;  
        nodek.x = nodes [ nodek.visibleParent ] .x+50*Math.random();
        nodek.y = nodes [ nodek.visibleParent ] .y+50*Math.random();
        //to put speed at 0: (px=previous x)
        nodek.px=nodek.x;
        nodek.py=nodek.y;

        //if (nodek.id=="EdouardPhilippe"){a=bb} 
      };


        looking = false;
        nodek .visibleParent =  current  ;  };

      } 

    } 
    //possible amélioration en mettant à jour les parents rencontrés au cours d'une remontée

    linksMap = [  ] ;  
    //on retournera une liste synthétique
    var linksSynth = [  ] ,   j = 0;
    for (var k = 0; k<links.length; ++k){  
       //on modifie les indices des sources pour qu'elles correspondent aux parents visibles 
      visibleSourceIndex = displayedNodesMap [nodeById( links [ k ] .source).visibleParent];
      visibleTargetIndex = displayedNodesMap [nodeById( links [ k ] .target ).visibleParent];

      if (visibleSourceIndex!= visibleTargetIndex){

        linkid = visibleSourceIndex+"|"+visibleTargetIndex;
        

        //link.source = visibleSourceId;
        //link.target = visibleTargetId;  //on ajoute a la liste entre ces 2 parents visibles 

        if (linksMap [ linkid ] ){  
          i = linksMap [ linkid ] ;
          linksSynth [ i ] .liste.push(links[k]);
          linksSynth[i].params={type:"multiple links",poste:""}
          console.log("multiple")
        }
        else {  

          linksMap [ linkid ] = j;  
          linksSynth [ j ] = {source:visibleSourceIndex,target:visibleTargetIndex,liste: [links[k]  ]};
          linksSynth [j].params=links[k].params||{};
          j = j+1; };  };
        }     



      

          console.log("dispnodes",displayedNodes)
          console.log("linkssynth",linksSynth)
          return {links: linksSynth, nodes: displayedNodes}

        }



// constructs the network to visualize


function convexHulls(nodes, nodesMap, offset) {
  var hulls = {};
  var parents = [  ] ;

  // create point sets
  for (var k = 0; k<nodes.length; ++k) {
    var n = nodes [ k ] ;


    var i = nodesMap [ n.parent ] //n.parent,
    l = hulls [ i ] || (hulls [ i ] = [  ] );
    l.push( [ n.x-offset, n.y-offset ] );
    l.push( [ n.x-offset, n.y+offset ] );
    l.push( [ n.x+offset, n.y-offset ] );
    l.push( [ n.x+offset, n.y+offset ] );
    l.parent = n.parent;

  } 

  // create convex hulls
  var hullset = [  ] ;
  for (i in hulls) { 
    hullset.push({parent: hulls [ i ] .parent, path: d3.geom.hull(hulls [ i ] )});
  }

  //if (data.nodes [ 23 ] .show) {a = bbb;}//23 4

  return hullset;
}

function drawCluster(d) {return curve(d.path); // 0.8
}

function nodeid(n) {
  return n.size ? "_g_"+n.group : n.id;
}



function zoomed() {
  vis.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}


function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed("dragging", true);
}

function dragged(d) {
  d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
}

function dragended(d) {
  d3.select(this).classed("dragging", false);
}




function infoDisp(object,classe) {


  infog.setAttribute("display", "block")



  //selection must have data object of the form "params":{"key1":"value1","key2":"value2", ...}, or no "params" at all
  //var attr="bla"; 
  var result;
  if (classe=="link") {
    fromField="";
    toField="";
    for (i in object.liste)
      { 
         fromField=fromField+(i==0?"":", ")+name(object.liste[i].source);
         toField=toField+(i==0?"":", ")+name(object.liste[i].target);
        }
      result=[["de",fromField],["vers",toField]];
    }  
    if (classe=="node"){
      result=[];
      if (object.children.length>0) {
          childrenNames="";
          for (i in object.children){
            childrenNames=childrenNames+ (i==0?"":", ")+(object.children[i].firstName+" "+(object.children[i].lastName||""));
          } 
          result.push(["",childrenNames]) 
      }
      if (object.linked.length>0){
        result.push(["liens avec",object.linked.map(name).join()]) 
      } 

    }  
    if (object.params) {result=result.concat(Object.entries(object.params))}; 
   

  infot
  .selectAll("tspan")
  .remove()
 
  
  infot
  .append("tspan")
  .attr("font-size",25)
  .text( classe=="node"? name(object.id):name(object.source.id)+' '+'\u25c0'+'\u25b6'+' '+name(object.target.id))
  .append("tspan")
  .attr("x",50)
  .attr("dy",object.params.poste==""?0:30)
  .selectAll("tspan")
  .data(object.params.poste.split(" "))
  .enter()
  .append("tspan")
  .attr("font-size",15)
  .each(cutAppendText)


  infot.selectAll("smalltext").data(result)
  .enter() 
  .append("tspan")
  .attr("class","smalltext")
  .attr("font-size",12)
  .filter( d => (typeof(d[1])=="object"?  d[1].texte!="" : d[1]!=""))
  .each(function(d){
      champ=d[0]+" : "
      texte=d3.select(this); 
      if (d[1].url){
          texte.append("a")
          .attr("href",d[1].url)
          .attr("target","_blank")
          .text( "("+(d[1].source||"source")+") ")
          .attr("stroke","blue")}
      texte.attr("x", 40)
  .attr("dy",(d,i)=> 20+(i==0? 20:0))
  .selectAll("tspan")
  .data(function(d) { 
    words=(typeof(d[1])=="object")? d[1].texte.split(" ") : d[1].split(" "); 
    words.unshift((d[0]=="")?"":d[0]+":") 
    return words;})
  .enter()
  .append("tspan")
  .each(cutAppendText)
  } )
  
 
   // textHeight=rect.parentNode.childNodes[1].getBBox().height;
    //textWidth=rect.parentNode.childNodes[1].getBBox().width;

    textHeight=infoTxt.getBBox().height;
    textWidth=infoTxt.getBBox().width;
     
    infoRect.setAttribute("height",textHeight+50)
    infoRect.setAttribute("width",textWidth+50)

}


function cutAppendText(d,i){
  var a
  d3.select(this)
  .attr("stroke",  (i==0)? "green" : "black")
  .attr("x",  (Number.isInteger((i+1)/8))?  60:a)
  .attr("dy",  (Number.isInteger((i+1)/8))?   20 :a)
  .text(d => d+" ");


}


 
function size(node) {
  r=1; //node.show? 0:1;
  for (i in node.children){
    r=r+size(node.children[i]);
  }
  return r;
}


function collapseNode(node){
//on peut simplifier avec des auto-appels récursifs
node.expanded=false;
 for (i in node.children) {
  console.log("close ",node.children[i])
    node.children[i].show=false;
    node.children[i].expanded=false;
    collapseNode(node.children[i])
  }
}

function expandNode(d)
{
        d.expanded=true;
      for (k  in d.children) { 
        d.children[k].prevShow=d.children[k].show;
        d.children [ k ] .show = true;};}


function nodeSort(n1,n2) {
  if (n2.expanded) {return 1}
  else if (n1.expanded) {return -1}
  else if (focus==n1.id){return 1}
  else if (focus==n2.id){return -1}
  else if (n1.parent==n2.id) {return 1}
  else if (n2.parent==n1.id) {return -1}
}

function linkSort(l1,l2) {
  if (focus==l1.source||focus==l1.target){return 1}
  else if (focus==l2.source||focus==l2.target){return -1}
}

function name(nodeId) {
  nodei=nodeById(nodeId);
  return nodei.firstName+" "+nodei.lastName;
}

function nodeById(id){
  return nodes[nodesMap[id]]
}
 
</script>
</body>
</html>
