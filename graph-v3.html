<!DOCTYPE html>
<meta charset = "utf-8">
<html>
<head>
  <title>Gouvernement Philippe II</title>

  <!--D3v3, textbox, hierarchy-->
  <script src = "https://d3js.org/d3.v3.min.js"></script>
  <script src="https://d3plus.org/js/d3plus.js"></script>
  



  <style type = "text/css">

  body {
    font: 10px sans-serif;
  }

  .boxname{
      fill: white;  
  }

  text{
  	font-family:American Typewriter, serif;
  }


  


  




  </style>
</head>
<body> 
  <div class="chart" id="mainchart"></div>
  <script type = "text/javascript">
  //var chartDiv=document.getElementsByClassName("wpd3-49-0")
  var chartDiv = document.getElementById("mainchart");
    

  //TO DO quand on clique sur une feuille, il faudrait qu'elle se rentre, et enlever l'info
  

  //TO DO:   changer polices, prendre en compte plusieurs parents, utiliser hierarchy package, bug quand on deploie certains petites feuilles, depth marche pas tres bien, faire drag noeuds et zoom texte sans propagation

//http://transparency-graph.fr/wp-content/uploads/2019/02/conflicts-files.txt
var filename="conflicts-file.txt",
divName="body", 
    width =1300,     // svg width
    height = width,     // svg height 
    dr = 34,      // default point radius
    off = dr,    // cluster hull offset 
    nodes = [],
    links=[],
    nodesMap =  {} ,  //"name" -> number
    focus = "Secteurpriv",
    infos=[],
    compteur=0,    
    infoWidth=0,
    infoTextSize=14,
    smallWidth=chartDiv.offsetWidth<600,
    net, force, hullg, hull, linkg, link, linkp,  nodeg ,   node,  infog,  infoG;

    curve = d3.svg.line()
    .interpolate("cardinal-closed")
    .tension(.85),

    fill = d3.scale.category20(); 
// --------------------------------------------------------

var body = d3.select(divName);

var canvas = body.append("svg").attr("id","canvas")
.style("border","1px solid #ccc")
.attr("width", width)
.attr("height", height);

var zoomCanvas=canvas.append("svg").attr("width", width).attr("id","zoomCanvas")
.attr("height", height);

//necessaire pr zoom
zoomCanvas.append("rect")
.attr("width", width)
.attr("height", height).attr("opacity",.1)

var vis = zoomCanvas.append("g").attr("id","vis") 


  //on met les elements svg dans l'ordre sur la page html
  hullg = vis.append("g").attr("id","hullg");//env. convexes
  linkg = vis.append("g").attr("id","linkg");//liens
  nodeg = vis.append("g").attr("id","nodeg");//nodeuds 
  infoG=canvas.append("g").attr("id","infog").attr("display",smallWidth?"none":"block");//infos

    //.on("click",noInfo) 
//zoom ability
var zoom = d3.behavior.zoom()
.scaleExtent( [ .1, 10 ] )
.scale(1)
.on("zoom", zoomed);


zoomCanvas.on("mouseover",function(){
  d3.select(this).style("cursor", "move")})
//.on("click", noInfo)
    .call(zoom) // delete this line to disable free zooming
    .call(zoom.event);


//info text when cursor is over convex hull
//crsrText = vis.append("text").attr("id","crsrtxt");






  infog=document.getElementById("infog")//automatic?

  /*infoG.append("rect")
  .attr("id","infoRect")
  .attr("x",20)
  .attr("y",20)
  .attr("rx","5px")
  .attr("width",1)
  .attr("height",1)
  .attr("fill","lightblue")
  .style("opacity",.9) */





  d3.json(filename,function(error, json) { 
    if (error) throw error;
    data = json;  
  ////console.log(data)

  //extract nodes
  for (var i = 0; i<data.length; ++i) {
    ////console.log(i)
    nodei = data[ i ] ;
    if (nodei.id!=""&& nodei.display!="no"){
      nodesMap [ nodei.id ] = nodes.length; 
      complete(nodei) 
      nodei.expanded=nodei.expanded||false;
      nodes.push(nodei)
      ////console.log(nodei,nodei.x)

    //on ajoute les liens de parenté
    links.push({source:nodei.id,  target:nodei.parent, params: {type:"belongsTo"}}); 
  }
} 
   
//console.log(nodes) 
  //world est tjs expanded
  nodes[0].expanded=true;


  //extract links
  for (var i=1; i<data.length; i++){

    linki=data[i].link||{target:""};

      //target="" veut dire que la ligne de donnees est vide
      if (linki.target!=""){
        links.push(linki)

      //on verifie que parent existe, ou target Parent
      if (nodesMap[linki.target]){
        ////console.log(linki.targetName," existe");
      }
      //s'il n'existe pas on est censes le creer comme enfant de "targetParentId"
      else if (linki.targetParentId) {
           //console.log("création de ",linki.targetName);
           nodesMap[linki.target]=nodes.length; 
           tgtName=linki.targetName.split(" ");
           nodei={
            id:linki.target,
            firstName:tgtName.shift(),
            lastName:tgtName.join(" "),
            parent:linki.targetParentId,
            expanded:false,
            params:{},
            poste:""}
            complete(nodei)
            nodes.push(nodei);
            links.push({source:linki.target,  target:linki.targetParentId, params: {type:"belongsTo"}});

          }
          else {console.log("parent inconnu",linki.parent);
          a=bb;
        }

        //pour chaque noeud on a la liste "linked", qui contient les noeuds avec lesquels il est lié, et une liste "links", qui contient les liens eux-mêmes
        nodeById(linki.source).linked.push(nodeById(linki.target));
        nodeById(linki.target).linked.push(nodeById(linki.source));
        nodeById(linki.source).links.push(linki);
        nodeById(linki.target).links.push(linki);
      }
    } 


  //build children lists and links
  for (var i = 1; i<nodes.length; ++i) { 
    
    nodei = nodes[ i ] ;   
    parent = nodeById( nodei.parent )
 
    nodei.show=parent.expanded; 
    parent.children.push(nodei);



  } 

  //on calcule les liens visibles et on lance la simulation
  init();

  //effet "apparition progressive"
  vis.attr("opacity", 1e-6)
  .transition()
  .duration(2000)
  .attr("opacity", 1);
});




function init() { 
  compteur=compteur+1;
  if (force) force.stop();//useful?
  ////console.log("------init - focus",focus)
  ////console.log("data",nodes,links) 
  
  net = network(nodes,links,nodesMap); 


  ////console.log(focusx,focusy) 
  adaptZoom(); 





  force = d3.layout.force()
  .nodes(net.nodes)
  .links(net.links)
  .size( [ width/2, height/2 ] )
  //.linkDistance(function(l, i) { return 600; })
  .linkStrength(function(l, i) { return ((l.source.id==focus) || (l.target.id==focus) || (l.params.type=="belongsTo"))? .3 : 0.1; })   
  .charge(function(n,i) {  return (n.id == focus?-8000:-6000);})
  //.gravity(0.1)
  .chargeDistance(800) 
  .friction(.6) 
  .start();



  //A noter: force transforme links: il remplace link.source.id par l'objet source, etc... 
  ////console.log("data",nodes,links)

  //convex hull cursor text------------
  /*vis.on("mouseover",function(){
    x = d3.mouse(this) [ 0 ] ;
    y = d3.mouse(this) [ 1 ] ;
    crsrText.attr("x",x)
    .attr("y",y)
    .attr("display","");
})

  vis.on("mousemove",function(){
    x = d3.mouse(this) [ 0 ] ;
    y = d3.mouse(this) [ 1 ] ;
    crsrText.attr("x",x)
    .attr("y",y)
    .attr("display","");
  })

  vis.on("mouseout",function(){  
    crsrText.attr("display","none");
  })*/

  //hulls display----------------------- 
  hullg.selectAll("path.hull").remove();
  hull = hullg.selectAll("path.hull")
  .data(convexHulls(net.nodes, nodesMap, off))
  .enter().append("path")
  .attr("class", "hull")
  .style("fill","blue")
  .style("opacity",d=>(3-depth(nodeById(d.parent)))/5)
  //.attr("d", drawCluster)
  .style("stroke-width","15px")
  .style("stroke", d => fill(nodeById(d.parent ).visibleParent ) )
  .on("mouseover",function(d){
    d3.select(this).style("cursor",  "crosshair")
    //crsrText.text(name(d.parent))
  }  )
  .on("click", function(d) {
    if (d.parent!= "world") {
      ////console.log("hull click", d, arguments, this); 
      focus = d.parent;  
      ////console.log("collaps")
      collapseNode(nodeById(d.parent));
      init(); 
    } 
  });  



  //nodes display------------------- 
  if (node) {node.remove();};//on peut aussi n'enlever que certains noeuds
  node = nodeg.selectAll(".node").data(net.nodes,d=>d.id);//, nodeid);

  //node.exit().remove();
  node.enter()
  .append("g") 
  .attr("class","node")
  .style("opacity", d=>d.expanded?1-depth(d)/3:1)
  /*
      var total=d.linked.length+d.children.length;
      var score=d.linked.length;
      for (i in d.children){
        score=score+(d.children[i].show?0:1)
      }
       
    }*/
    .attr("font-size","18px")
    .attr("text-anchor","middle") 
    .attr("transform",d => "translate("+d.x+","+d.y+")")
    .on("mouseover", function(d) { 
     d3.select(this).style("cursor",  d.id==focus? d.expanded?"crosshair":"col-resize":"help")
     lightNodeLinks(d,"on")
   }).on("mouseout", function(d){lightNodeLinks(d,"off")} )
    .on("click", function(d) { 
        
        //si l'info du noeud n'est pas déjà affichée, on l'affiche, avec ses enfants et ses liens
        if (infos[0]!=d) {
        noInfo();
        d.showInfo=true;
        infos=[d]

        if (d.children.length>0){
          infos.push({texte:"Contient","off":10,"showInfo":true})
          for (i in d.children){ 
            infos.push(d.children[i])
          }
        }

        
        if (d.links.length>0){
        infos.push({texte:"Liens","off":10,"showInfo":true})

        infos=infos.concat(d.links)
        }
        infoDisp()
      }
      else if (d.children.length==0){noInfo()}

        if (focus==d.id){
          if (d.expanded) {
            collapseNode(d);}
            else if (d.children.length>0)
              {expandNode(d)}
              d.show=nodeById(d.parent).expanded; 
          }

        //on range l'ancien focus, sauf si on clique sur un noeud déballé
        setFocus(focus,d);
        //console.log(d)
        focus = d.id;
        init();
      })

    nodec=node.append("circle") 
    .attr("stroke-width","5px")
    .attr("stroke",d=> stroke(d))
    .style("fill-opacity", d=>d.expanded? 0:1)
    .attr("r",d=>dr+ 10+size(d)*0.5)
    .attr("cx",0) 
    .attr("cy",0) 
    .style("fill", d => d.expanded? fill(nodesMap[d.id]) : fill(nodeById(d.parent).visibleParent ))



  //.on("mouseout",d =>  infog.setAttribute("display","none"));

  node.append("rect")
  .attr("class","boxname top") 


  node.append("rect")
  .attr("class","boxname middle") 

  node.append("text") 
  .attr("x",0)
  .style("font-family","American Typewriter, serif")
  .attr("y",d => d.lastName? "-1.2em" : 0)
  .text( d => d.firstName) 
  .each(function(d){
    box=this.parentNode.getBBox();
    d.bb1x=-box.width/2-5;
    d.bb1w=box.width+10;
  })

  node.selectAll(".top")
  //.attr("rx",10)
  .attr("x",d=>d.bb1x-2)
  .attr("y",-37)
  .attr("display",d=>d.lastName?"block":"none")
  .attr("width",d=>d.bb1w||10)
  .attr("height",21)
 

  node.append("text") 
  .style("font-size","18px")
  .style("font-family","American Typewriter, serif")
  .attr("x",0)
  .attr("y", 0)
  .text( d => d.lastName||"")  
  .each(function(d){
    box=this.getBBox();
    d.bb2x=-box.width/2-5;
    d.bb2w=box.width+10;
  }) 


  node
  .selectAll(".middle")
  //.attr("rx",6)
  .attr("x",d=>d.lastName?d.bb2x+2:d.bb1x+2)
  .attr("y",-14)
  .attr("width",d=>d.lastName?d.bb2w:d.bb1w)
  .attr("height",23)
  
  node.append("text")
  .style("font-size","10px")
  .style("font-family","American Typewriter, serif")
  .attr("dy","2em")
  .text(d => name(d.parent))  

  //only for mouseover event
  node.append("circle") 
  .style("opacity", .001)
  .attr("r",d=>dr+ 10+size(d)*0.5)  
  


  node.sort(nodeSort)


  //links display------------
  if (link) {link.remove();};//on pourrait aussi n'enlever que certains liens
  link = linkg.selectAll("link").data(net.links);


  link.enter().append("g")
  .attr("class","link")
  .attr("transform", d => "translate(" + d.source.x + "," + d.source.y + ")")
  .on("mouseover", function(d){ 
    d3.select(this).style("cursor", "help")
    lightLink(d.source.id,d.target.id,"on")})
  .on("mouseout", d  => lightLink(d.source.id,d.target.id,"off"));

  linkp = link.append("polygon")
  .attr("class",d => ((d.source.id == focus)||(d.target.id == focus))? "focus":"background")
  .attr("stroke",d=> ((d.source.id == focus)||(d.target.id == focus))? "red":"grey" )
  .attr("opacity",d=> ((d.source.id == focus)||(d.target.id == focus))? 1:0.2 )
  .attr("points",function(d) {
    var dx = d.target.x-d.source.x;
    var dy = d.target.y-d.source.y;
    return "0 0 "+dx+" "+dy}) 
  .attr("display",d => d.params.type=="belongsTo"?   "none" : "block")
  .style("stroke-width", d => d.params.type=="belongsTo"?   1 : 10)  
  .on("click", function(d){
    focus=d.source.id;
    noInfo();
    infos=[d,{texte:"Liens","off":10,"showInfo":true}]
    for (i in d.liste){
      infos.push(d.liste[i])
    }

    infoDisp();
  });

  link.sort(linkSort)



//Force updates------------------------------

//node.call(force.drag);

force.on("tick", function(e) { 
  if (!hull.empty()) {
    hull.data(convexHulls(net.nodes, nodesMap, off))
    .attr("d", drawCluster);
  }

  minY= net.nodes.reduce((min, p) => p.y < min ? p.y : min, net.nodes[0].y);
  maxX= net.nodes.reduce((max, p) => p.x > max ? p.x : max, net.nodes[0].x);
  minX= net.nodes.reduce((min, p) => p.x < min ? p.x : min, net.nodes[0].x);


  ////console.log(minX)
  left=300;
  middle= (width+left)/2


  node.each(function(d){
    ////console.log(d.id,d.x)
    //textw=100+infoTxt.getBBox().width;
    ////console.log(textw)
    d.x=minX<100? d.x+50*e.alpha:d.x//:d.x>width?d.x-d.x+100*e.alpha:d.x;
    d.y=minY<0?d.y+50*e.alpha:d.y;

    //d.y=d.y<40?d.y+10*(40-d.y)*e.alpha:d.y;
  }) 

  node.attr("transform", d => "translate(" + (d.x) + "," + (d.y) + ")" );  


  link
  .attr("transform", d => "translate(" + (d.source.x )+ "," + (d.source.y) + ")" ) 

  linkp.attr("points",function(d) {
    var dx = (d.target.x)-(d.source.x);
    var dy = (d.target.y)-(d.source.y);
    return "0 0 "+dx+" "+dy}) 




});

}





/*function linkid(l) {
  var u = nodeid(l.source),
  v = nodeid(l.target);
  return u<v ? u+"|"+v : v+"|"+u;
}*/



function network(nodes,links,nodesMap){ 
  var displayedNodes = [  ] ,  
  displayedNodesMap = [  ] ,  
  i = 0; 

  //build nodes maps (except world)
  for (var k = 1; k<nodes.length; ++k){
    nodek = nodes [ k ] ;

    if (nodek.show) {
      displayedNodes.push(nodek);
      displayedNodesMap [ k ] = i;
      i++;
    }  
  }  

  nodes[0].visibleParent=1;

  //on determine le parent visible de chacun
  for (var k = 1; k<nodes.length; ++k){ 
    ////console.log(k)
    var looking = true;
    var current = k; 
    nodek=nodes[k];  
    while (looking ){  
      crtNode = nodes [ current ] ; 
      parentIndex = nodesMap [ crtNode.parent ] ;  
      if (crtNode.show == false ) {//si le noeud est caché
      //on va regarder si son parent est visible
      current = parentIndex; 
    } 
    else {
        //crtNode est le visibleparent
        if (nodek.show!=nodek.prevShow) {
        //just popped 
        nodek.prevShow=true; 
        //console.log(nodek) 
        //on les fait apparaitre pres de leur visibleparent
        nodek.x = nodes [ nodek.visibleParent ] .x+350*Math.random();
        nodek.y = nodes [ nodek.visibleParent ] .y+350*Math.random();
        //to put speed at 0: (px=previous x)
        nodek.px=nodek.x;
        nodek.py=nodek.y;

        //if (nodek.id=="EdouardPhilippe"){a=bb} 
      };  

      looking = false;

        //cet attribut servira plus tard pour l'affichage des couleurs et des enveloppes
        nodek .visibleParent =  current  ; 


      }  

    }
  }  
    //possible amélioration en mettant à jour les parents rencontrés au cours d'une remontée

    //on construit desormais les liens visibles
    linksMap = [  ] ;  
    //on retournera une liste synthétique sans répétition ou auto-lien, "linkssynth"
    var linksSynth = [  ] ,   j = 0;
    for (var k = 0; k<links.length; ++k){  
       //on modifie les indices des sources pour qu'elles correspondent aux parents visibles 
       visibleSourceIndex = displayedNodesMap [nodeById( links [ k ] .source).visibleParent];
       visibleTargetIndex = displayedNodesMap [nodeById( links [ k ] .target ).visibleParent];

       if (visibleSourceIndex!= visibleTargetIndex){

        linkid = visibleSourceIndex+"|"+visibleTargetIndex;
        

        //link.source = visibleSourceId;
        //link.target = visibleTargetId;  //on ajoute a la liste entre ces 2 parents visibles, ou on la créee

        if (linksMap [ linkid ] ){  
          i = linksMap [ linkid ] ;
          linksSynth [ i ] .liste.push(links[k]);
          linksSynth[i].params={type:"Liens multiples",poste:""}
          ////console.log("multiple")
        }
        else {  

          linksMap [ linkid ] = j;  
          linksSynth [ j ] = {
            source:visibleSourceIndex,
            target:visibleTargetIndex,
            liste: [links[k]  ], 
            poste:"",
            params:links[k].params||{}};
            j = j+1; };  };
          }     


          return {links: linksSynth, nodes: displayedNodes}

        }



// constructs the network to visualize


function convexHulls(nodeGrp, nodesMap, offset) {
  var hulls = {};
  var parents = [  ] ;
  //console.log(nodeGrp)
  // create point sets - not for world
  for (var k = 1; k<nodeGrp.length; ++k) {
    var n = nodeGrp [ k ] ;

    //on rajoute ce noeud dans le visibleparent de son parent (il se peut que seuls le noeud et son grand parent soient visibles)
    var i =  nodeById(n.parent).visibleParent  
    //console.log(i)
    l = hulls [ i ] || (hulls [ i ] = [
     [  nodes[i].x-offset, nodes[i].y-offset],
     [  nodes[i].x-offset, nodes[i].y+offset],
     [  nodes[i].x+offset, nodes[i].y-offset],
     [  nodes[i].x+offset, nodes[i].y+offset],
     ] );
    l.push( [ n.x-offset, n.y-offset ] );
    l.push( [ n.x-offset, n.y+offset ] );
    l.push( [ n.x+offset, n.y-offset ] );
    l.push( [ n.x+offset, n.y+offset ] );
    l.parent = n.parent;
    //console.log(hulls)


  }   
  //a=bb

  // create convex hulls
  var hullset = [  ] ;
  for (i in hulls) { 
    hullset.push({parent: hulls [ i ] .parent, path: d3.geom.hull(hulls [ i ] )});
  }

  //if (data.nodes [ 23 ] .show) {a = bbb;}//23 4

  return hullset;
}

function drawCluster(d) {return curve(d.path); // 0.8
}

function nodeid(n) {
  return n.size ? "_g_"+n.group : n.id;
}



function zoomed() { 
/*prevTgt=msTgt;
msTgt="world"//d3.event.sourceEvent.target.id||"world";
if (msTgt=="canv" && prevTgt=="canv") {*/
    ////console.log("mvvvvv") 
    vis.attr("transform", "translate("+d3.event.translate+")scale(" + (d3.event.scale) + ")")
    //infoG.attr("transform", "translate(0,"+d3.event.translate[0]+")")


  }




  function adaptZoom(){  
  //calcul du nouveau zoom basé sur le nb de noeuds.
  autoZoom=(width-100)/(200*(infoWidth/150+Math.sqrt(net.nodes.length)+1))

  //on recale le canvas a gauche du texte, le graphe est censé translater tout seul via une force spécifique
  vis.transition().duration(2000).call(zoom.translate([infoWidth+100,100]).scale(autoZoom).event);

}

function noInfo() {
  //console.log("noinfo")
  infoWidth=0; 
  infoG.selectAll(".infoblock").remove();
  for (i in infos){
  	infos[i].showInfo=false;
  }
  infos=[];
  adaptZoom()
}

function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}
/*function dragstarted(d) {
  ////console.log("dstart")
  a=bb
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed("dragging", true);
}

function dragged(d) {
  ////console.log("dd")
  d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
}

function dragended(d) {
  ////console.log("dend")
  d3.select(this).classed("dragging", false);
}*/




function infoDisp() { 
  //console.log(object)

  //parametres constants
  infoWidth=smallWidth?0:300;

  //on enleve tout
  infoG.selectAll(".infoblock").remove()




  var off=10;
  //sert à mettre la croix de fermeture
  var firstBlock=true;
  //sert à savoir si on affiche le prochain subblock
  var displaySubBlocks=true;

  for (i in infos){
    d=infos[i]   
    prevHeight=smallWidth?0:infog.getBBox().height+5;

    //cadre titre
    info=infoG.append("g")
    .data([d])
    .attr("class","infoblock")
    .attr("transform", "translate("+(d.off||off)+","+prevHeight+")") 

    //rectangle du cadre titre
    info.append("rect")
    .data([d]).attr("fill","grey")
    .attr("height",30)
    .attr("width",infoWidth)
    .attr("stroke-width",2)
    .attr("stroke","black")
    .style("opacity",.4)
    .attr("rx",5)

    //rectangle de deploiement
    info.append("text")
    .attr("x",5)
    .attr("y",20)
    .attr("font-size",15)
    .text(d.showInfo?"\u25bc"||"V":"\u25b6"||">")
    .on("click",function(d){
      d.showInfo=d.showInfo?false:true;
      infoDisp()
    })


    //croix de fermeture
    closeBox=info.append("g")
    .attr("transform","translate("+infoWidth+",1)")
    .attr("display",firstBlock?"block":"none")
    .on("click",noInfo )


    firstBlock=false;

    closeBox.append("rect")
    .attr("x",-28)
    .attr("height",28)
    .attr("width",28)
    .attr("fill","white")
    .attr("rx",5)
    
    closeBox.append("text")
    .attr("x",-27)
    .attr("y",23)
    .attr("font-size",26)
    .text("\u2573"||"X")



    if (d.texte=="Liens"||d.texte=="Contient"){ 
      displaySubBlocks=d.showInfo

      info.append("text")
      .text(d.texte)
      .attr("x",31)
      .attr("y",20)
      .attr("font-size",16)

      off=20;
    }
    else if (displaySubBlocks){ 


      //transform result en key/value

      //textwrap bug et n'affiche pas la 1re info donc je mets une info vide pour contrer ça
      var result=[["",""]];
      if (d.source) {//il s'agit d'un lien
        fromField="";
      toField="";
      for (i in d.liste)
      { 
       fromField=fromField+(i==0?"":", ")+name(d.liste[i].source);
       toField=toField+(i==0?"":", ")+name(d.liste[i].target);
     }
     result.push(["de",{"texte":fromField}],["vers",{"texte":toField}]);
   }  
     else { //il s'agit d'un noeud
      if (d.children.length>0&&(i>0)) {
        childrenNames="";
        for (i in d.children){
          childrenNames=childrenNames+ (i==0?"":", ")+(d.children[i].firstName+" "+(d.children[i].lastName||""));
        } 
        result.push(["Contient:",{"texte":childrenNames}]) 
      }
      if (d.linked.length>0){
        //maybe problem because linked contains objects now, not just ids
        
        result.push(["liens avec",{"texte":d.linked.map(n=>name(n.id)).join()}]) 
      }  

    }  
    if (d.params) {result=result.concat(Object.entries(d.params))}; 





    var id=d.id?name(d.id):d.source.id? name(d.source.id)+(" \u2b0c "||" <-> ")+name(d.target.id):name(d.source)+(" \u2b0c "||" <-> ")+name(d.target);

    info.append("text")
    .text( id)
    .attr("font-size",d.source?10:15)
    .attr("x",30)
    .attr("y",20)

    bckgrdRect=info.append("rect")
    .attr("fill","white")
    .attr("y",30)
    .attr("height",0)
    .attr("width",infoWidth)
    .style("opacity",.8)


    infoSubBlock=info.append("text") 
    .attr("display",d.showInfo?"block":"none")
    .selectAll(".smalltext")
    .data(result)
    .enter() 

    //on met a jour la hauteur du bloc au fur et a mesure
    blockHeight=48;
    //on met les textes avant les titres pour calculer la hauteur du bloc au passage
    infoSubBlock
    .append("tspan") 
    .filter(d=>d[1].texte)
    .attr("class","smalltext")
    .attr("y",function(d){ 
      d.height=blockHeight;   
      //calcul approximatif de la hauteur du texte une fois formatté   
      blockHeight=blockHeight+infoTextSize*Math.floor(3+.55*d[1].texte.length*infoTextSize/infoWidth);
      return d.height
    })
    .text(d=>d[1].texte)
    .attr("font-size",infoTextSize)
    .each(function() {
      d3plus.textwrap()
      .container(d3.select(this))
      .width(infoWidth)
      .height(height)
      .draw(); 
    })
    //on saute une ligne à la fin
    .append("tspan")
    .text("   ")
    .attr("dy",20);

    //on place les titres
    infoSubBlock
    .append("tspan")
    .filter(d=>d[1].texte)
    .text(d=>d[0])
    .attr("stroke","green")
    .attr("stroke-width",.5)
    .attr("font-size",16)
    .attr("y",d=>d.height) //calculé dans le bloc d'avant
    .attr("x",0)
    .append("a")
    .attr("href",d=>d[1].url)
    .attr("target","_blank")
    .text(d=>d[1].url?" (source "+d[1].source+")"
      :"")
    .attr("font-size",10)
    .attr("stroke","blue")


    //on calcule la nouvelle hauteur pour placer le prochain bloc
    newHeight=smallWidth?0:infog.getBBox().height-25-prevHeight;
    bckgrdRect.attr("height",newHeight)



  }
  else{
    info
    .style("display","none") 
  }

}//end of for loop

adaptZoom()

}//end of function


function cutAppendText(d,i){
  var a
  d3.select(this)
  .attr("stroke",  (i==0)? "green" : "black")
  .attr("x",  (Number.isInteger((i+1)/5))?  60:a)
  .attr("dy",  (Number.isInteger((i+1)/5))?   20 :a)
  .text(d => d+" ");


}

function depth(node) { 
  d=0;
  children=node.children;
  while (children.length>0){ 
    children=children[0].children;
    d=d+1
  }
  return d;
}

function size(node) {
  r=1; //node.show? 0:1;
  for (i in node.children){
    r=r+size(node.children[i]);
  }
  return r;
}


function collapseNode(node){
//on peut simplifier avec des auto-appels récursifs
node.expanded=false;
for (i in node.children) {
  ////console.log("close ",node.children[i])
  node.children[i].show=false;
  node.children[i].expanded=false;
  collapseNode(node.children[i])
}
}

function expandNode(d)
{
  d.expanded=true;
  for (k  in d.children) { 
    d.children[k].prevShow=d.children[k].show;
    d.children [ k ] .show = true;};}


    function nodeSort(n1,n2) {
      if (n2.expanded) {return 1}
        else if (n1.expanded) {return -1}
          else if (focus==n1.id){return 1}
            else if (focus==n2.id){return -1}
              else if (n1.parent==n2.id) {return 1}
                else if (n2.parent==n1.id) {return -1}
              }

            function linkSort(l1,l2) {
              if (focus==l1.source||focus==l1.target){return 1}
                else if (focus==l2.source||focus==l2.target){return -1}
              }

            function name(nodeId) {
              nodei=nodeById(nodeId);
              return nodei.firstName+" "+nodei.lastName;
            }

            function nodeById(id){
              return nodes[nodesMap[id]]
            }

            function setFocus(focus,d){
  //console.log("nm",nodesMap)

  focusLinked=nodeById(focus).linked;

  for (k in focusLinked){
    nodek=focusLinked[k];
    nodek.show=nodeById(nodek.parent).expanded? true: d.id==nodek.id? true: false;
    nodek.prevShow=true; 
  } 
        //on installe le nouveau focus
        
        focusLinked=nodeById(d.id).linked;
        for (k in focusLinked){
          nodek=focusLinked[k];
          nodek.prevShow=nodek.show;
          nodek.show=true;
        }  }


        function lightNodeLinks(d,p){ 
          lightNode(d.id,"on") 
          for (i in net.links){

            if (net.links[i].source.id==d.id) { 
              lightLink(d.id,net.links[i].target.id,p)}
//console.log(i,net.links[i].target,net.links[i])
              if (net.links[i].target.id==d.id) { 
                lightLink(net.links[i].source.id,d.id,p)}
              }


            }



            function lightNode(id,p){;
  //console.log(id)
  nodec.filter(d=>(d.id==id)).attr("stroke",p=="on"? "orange": "grey")
}


function lightLink(id1,id2,p){
  //console.log("hop",id1,id2)
  linkp.filter(
    d=>
    (d.source.id==id1&&d.target.id==id2))
  .attr("stroke",d=>p=="on"?"orange":((d.source.id == focus)||(d.target.id == focus))? "red":"grey")
  .attr("opacity",d=>p=="on"?1:((d.source.id == focus)||(d.target.id == focus))? 1:0.2)
  lightNode(id1,p)
  lightNode(id2,p)
}


function stroke(d){
  return (d.id==focus)? "red":d.children.length>0?"darkgrey":'lightgrey'
}

function complete(n){
  n.children = [  ] ;
  n.x = 100+width*Math.random();
  n.y = 300*Math.random(); 
  n.px = n.x
  n.py = n.y; 
  n.prevShow=false;
  n.linked=[];
  n.links=[];
  n.showInfo=false;
  n.visibleParent=nodes.length;
}



</script>
</body>
</html>
